#include <stdio.h>
#include <stdlib.h>

/*
 * Функция sign(x)
 * Возвращает:
 *  1  — если x > 0
 *  0  — если x = 0
 * -1  — если x < 0
 * Используется в формуле для i_{k+1}
 */
int sign(int x) {
    if (x > 0) return 1;
    if (x < 0) return -1;
    return 0;
}

/*
 * Математическая операция взятия по модулю.
 * В отличие от оператора % в языке C,
 * результат всегда лежит в диапазоне [0, m-1],
 * даже если a < 0.
 */
int mod(int a, int m) {
    int r = a % m;
    if (r < 0) r += m;
    return r;
}

int main() {
    /* Начальные данные для задания №17 */
    int i = 13;   // i_0
    int j = 19;   // j_0
    int l = 14;   // l_0

    /* Текущее дискретное время */
    int k = 0;

    /* Максимальное число шагов по условию */
    const int max_steps = 50;

    /* Номер шага попадания в полосу (-1, если не было) */
    int hit_step = -1;

    /* Заголовок таблицы траектории */
    printf("k\ti\tj\tl\ti+j\n");

    /* Вывод начального состояния (k = 0) */
    printf("%d\t%d\t%d\t%d\t%d\n", k, i, j, l, i + j);

    /*
     * Основной итерационный цикл.
     * На каждом шаге вычисляются значения i_{k+1}, j_{k+1}, l_{k+1}
     * по рекуррентным соотношениям задания.
     */
    for (k = 0; k < max_steps; k++) {

        int i_new, j_new, l_new;

        /*
         * Вычисление i_{k+1}:
         * i_{k+1} = sign(i_k + 1) * | |k - j_k| - |i_k - l_k| |
         */
        i_new = sign(i + 1)
              * abs(abs(k - j) - abs(i - l));

        /*
         * Вычисление j_{k+1}:
         * j_{k+1} = (j_k mod 20)
         *          + max( i_k mod 20 , min(|j_k - k|, l_k - k) )
         *          - 10
         */
        j_new = mod(j, 20)
              + ( (mod(i, 20) > (abs(j - k) < (l - k)
                  ? abs(j - k)
                  : (l - k)))
                  ? mod(i, 20)
                  : (abs(j - k) < (l - k)
                     ? abs(j - k)
                     : (l - k)) )
              - 10;

        /*
         * Вычисление l_{k+1}:
         * l_{k+1} = ( k * (i_k + 1) * (j_k + 2) * (k + 3) ) mod 20
         */
        l_new = mod(k * (i + 1) * (j + 2) * (k + 3), 20);

        /* Переход к следующему шагу */
        i = i_new;
        j = j_new;
        l = l_new;

        /* Вывод текущего состояния системы */
        printf("%d\t%d\t%d\t%d\t%d\n", k + 1, i, j, l, i + j);

        /*
         * Проверка попадания точки в заданную полосу:
         * -20 <= i + j <= -10
         */
        if (i + j >= -20 && i + j <= -10) {
            hit_step = k + 1;
            break;   // Завершаем моделирование
        }
    }

    /* Итоговый вывод */
    printf("\nРЕЗУЛЬТАТ:\n");

    if (hit_step != -1) {
        printf("Попадание в заданную полосу на шаге %d\n", hit_step);
    } else {
        printf("Промах: за %d шагов точка не попала в полосу\n", max_steps);
    }

    printf("Конечные значения:\n");
    printf("i = %d, j = %d, l = %d\n", i, j, l);
    printf("i + j = %d\n", i + j);

    return 0;
}